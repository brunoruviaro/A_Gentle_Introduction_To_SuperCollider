\section{Mix e Splay}

Este é um truque bacana. Você pode usar expansão multicanal para gerar sons complexos e depois mixá-los todos para mono ou estéreo com \texttt{Mix} ou \texttt{Splay}:
 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// saída com 5 canais (veja a janela Meter)
a = { SinOsc.ar([100, 300, 500, 700, 900], mul: 0.1) }.play;
a.free;
// Mixe em mono:
b = { Mix(SinOsc.ar([100, 300, 500, 700, 900], mul: 0.1)) }.play;
b.free;
// Mixe em estéreo (distribuição uniforme da esquerda para a direita)
c = { Splay.ar(SinOsc.ar([100, 300, 500, 700, 900], mul: 0.1)) }.play;
c.free
// Divirta-se com Splay:
(
d = {arg fundamental = 110;
	var harmonicos = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	var som = BPF.ar(
		in: Saw.ar(32, LFPulse.ar(harmonicos, width: 0.1)),
		freq: harmonicos * fundamental,
		rq: 0.01,
		mul: 20);
	Splay.ar(som);	
}.play;
)
d.set(\fundamental, 100); // mude a fundamental apenas pela diversão
d.free;
\end{lstlisting}
 
Você consegue ver a expansão multicanal funcionando com este último exemplo de \texttt{Splay}? A única diferença é que o array é primeiro armazenado em uma variável (\texttt{harmonicos}) antes de se utilizada nas UGens. O array \texttt{harmonicos} tem 9 items, então o sintetizador irá se expandir para 9 canais. Então, um pouco antes de \texttt{.play}, \texttt{Splay} recebe o array de 9 canais e os mixa em estéreo, distribuindo os canais uniformemente da esquerda para a direita.\footnote{A última linha antes do \texttt{.play} poderia ser explicitamente escrita como \texttt{Out.ar(0, Splay.ar(som))}. Lembre-se que o SuperCollider está gentilmente preenchendo as lacunas e inserindo aí um
\texttt{Out.ar(0...)}---é assim que o sintetizador sabe que deve tocar nos canais esquerdo (bus 0) e direito (bus a).}

\texttt{Mix} tem um outro truque interessante: o método \texttt{fill}. De uma só vez, ele cria um array de sintetizadores e os mixa em mono.

\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Gerador instantâneo de clusters
c = { Mix.fill(16, {SinOsc.ar(rrand(100, 3000), mul: 0.01)}) }.play;
c.free;
// Uma nota com 12 parciais com amplitudes decrescentes
(
n = { Mix.fill(12, {arg contador;
	var parcial = contador + 1; // queremos começar do 1, não do 0
	SinOsc.ar(parcial * 440, mul: 1/parcial.squared) * 0.1
	})
}.play;
FreqScope.new;
)
n.free;
\end{lstlisting}

Você fornece duas coisas para o \texttt{Mix.fill}: o tamanho do array e uma função (entre chaves) que será utilizada para preencher o array. No primeiro exemplo acima, \texttt{Mix.fill} executa a função 16 vezes. Note que a função inclui um componente variável: a frequência do oscilador senoidal que pode ser qualquer número entre 100 e 3000. Dezesseis senoides serão criadas, cada uma com uma frequência aleatória diferente. Todas elas serão mixadas em mono e você ouvirá o resultado no seu canal esquerdo.
O segundo exemplo mostra que a função pode receber um argumento de "contador" que monitora o número de iterações (como em \texttt{Array.fill}). 
Doze osciladores senoidais são gerados seguindo a série harmônica e mixados como uma única nota em mono.
