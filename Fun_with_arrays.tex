\section{Divirta-se com Arrays}
\label{sec:arrays}

Arrays [N.T.: em computação, o termo "array" pode ser traduzido como "vetor", mas é comum mantê-lo no original] são o tipo mais comum de coleção no SuperCollider. Toda vez que você escreve uma coleção de itens entre colchetes, como \texttt{[0, 1, 2]}, cria uma instância da classe \texttt{Array}. Frequentemente, você se verá manipulando arrays de diversas formas. Aqui está uma pequena seleção de métodos interessantes que arrays entendem:

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Criar uma array
a = [10, 11, 12, 13, 14, 15, 16, 17];

a.reverse; // inverter
a.scramble; // embaralhar
a.choose; // escolher um elemento ao acaso
a.size; // retorna o tamanho da array
a.at(0); // recupera um item na posição especificada
a[0]; // o mesmo que acima
a.wrapAt(9); // recupera item na posição especificada, relendo do início se > a.size
["wow", 99] ++ a; // concatena duas arrays em uma nova
a ++ \oi; // um Símbolo é entendido como um único caracter
a ++ 'oi'; // o mesmo que acima
a ++ "oi"; // uma cadeia ("String") é entendida como uma coleção de caracteres
a.add(44); // cria uma nova array adicionando o novo elemento ao final
a.insert(5, "uau"); // insere "uau" na posição 5, empurra itens seguintes para a frente (retorna uma nova array)
a; // rode isso e veja que nenhuma das operações acima mudou a array original
a.put(2, "oops"); // colocar "oops" no índice 2 (destrutivo; volte a rodar a linha acima para verificar)
a.permute(3); // permutar: item na posição 3 vai para a posição zero, e vice-versa
a.mirror; // faz um palíndromo
a.powerset; // retorna todas as possíveis combinações dos elementos da array
\end{lstlisting}
 

Você pode fazer contas com arrays:

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
[1, 2, 3, 4, 5] + 10;
[1, 2, 3, 4, 5] * 10;
([1, 2, 3, 4, 5] / 7).round(0.01); // note o uso de parênteses para precedência
x = 11; y = 12; // experimente algumas variáveis
[x, y, 9] * 100;
// mas garanta que você só faça contas com números de verdade
[1, 2, 3, 4, "oops", 11] + 10; // resultado estranho
\end{lstlisting}
 

\subsection{Creating new Arrays}

Aqui há algumas maneiras de usar a classe \texttt{Array} para criar novas coleções:

\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Progressão aritmética (definindo tamanho, início e passo da progressão)
Array.series(size: 6, start: 10, step: 3);
// Progressão geométrica (definindo tamanho, início e razão da progressão)
Array.geom(size: 10, start: 1, grow: 2);
// Compare as duas:
Array.series(7, 100, -10); // 7 itens; começando em 100, passo de -10
Array.geom(7, 100, 0.9); // 7 itens; começando em 100; multiplicar por 0.9 a cada vez
// Conheça o método .fill
Array.fill(10, "igual");
// Compare:
Array.fill(10, rrand(1, 10)); 
Array.fill(10, {rrand(1, 10)}); // a função é reexecutada 10 vezes
// A função definida como segundo arg do método .fill pode receber um contador como argumento padrão.
// O nome do argumento pode ser o que você quiser.
Array.fill(10, {arg contador; contador * 10});
// Por exemplo, gerando uma lista de frequências harmônicas:
Array.fill(10, {arg uau; uau+1 * 440}); 
// O método .newClear
a = Array.newClear(7); // cria uma array vazia do tamanho desejado
a[3] = "uau"; // mesmo que a.put(3, "uau")
\end{lstlisting}


\subsection{Aquele ponto de exclamação esquisito}

É só uma questão de tempo até que você veja algo como \texttt{30!4} no código de alguém. Essa notação abreviada simplesmente cria uma array contendo o mesmo item um determinado número de vezes:

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Notação abreviada:
30!4;
"alô" ! 10;
// Dá o mesmo resultado que o seguinte:
30.dup(4);
"alô".dup(10);
// ou
Array.fill(4, 30);
Array.fill(10, "alô");
\end{lstlisting}
 

\subsection{Os dois pontos entre parênteses}

Aqui está mais uma sintaxe abreviada muito usada para criar arrays.

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Que diabo é isso?
(50..79);
// É um atalho para gerar uma array com uma progressão numérica aritmética.
// O atalho acima tem o mesmo resultado que:
series(50, 51, 79);
// ou
Array.series(30, 50, 1);
// Para um passo (razão) diferente de 1, você pode fazer o seguinte:
(50, 53 .. 79); // de 3 em 3
// Mesmo resultado que:
series(50, 53, 79);
Array.series(10, 50, 3);
\end{lstlisting}

Note que cada comando implica um jeito de pensar ligeiramente diferente. O \texttt{(50..79)} permite que você pense assim: "\emph{me dê uma array de 50 a 79}." Você não precisa necessariamente pensar a quantidade de itens que a lista vai conter. Por outro lado, \texttt{Array.series} permite pensar: "\emph{me dê uma array com 30 itens no total, começando a partir do 50}." Você não precisa necessariamente pensar qual será o último número da série.

Também note que o atalho usa parênteses, não colchetes. A array resultante, naturalmente, virá entre colchetes.
\subsection{Como "fazer" um Array}

Muitas vezes você vai precisar realizar alguma operação com cada um dos itens de uma coleção. Você pode usar o método \texttt{do} ("faça") para isso:


\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
~minhasFreqs = Array.fill(10, {rrand(440, 880)});

//Agora vamos fazer uma ação simples com cada um dos itens da lista:
~minhasFreqs.do({arg item, contador; ("Item " ++ contador ++ " é " ++ item ++ " Hz. A nota MIDI mais próxima é " ++ item.cpsmidi.round).postln});

// Se você não precisa do contador, use apenas um argumento:
~minhasFreqs.do({arg item; item.squared.postln});

// Claro que algo simples como o exemplo anterior poderia ser feito assim:
~minhasFreqs.squared;
\end{lstlisting}
 

Em resumo: quando você processa uma array com "do", você fornece uma função. A mensagem \texttt{"do"} vai cuidar de executar a função uma vez para cada item constante da array. A função pode receber dois argumentos por definição: o item da vez propriamente dito, e um contador que vai registrando o número de iterações já realizadas. Os nomes destes argumentos podem ser o que você quiser, mas estarão sempre nesta ordem: item, contador.

Veja também o método \texttt{collect}, que é muito similar ao \texttt{do}, mas retorna uma nova coleção com todos os resultados intermediários.
