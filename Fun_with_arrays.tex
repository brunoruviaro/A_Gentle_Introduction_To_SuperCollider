\section{Divirta-se com Arrays}
\label{sec:arrays}

Arrays [N.T.: em computação, o termo “array” pode ser traduzido como “vetor”, mas é comum mantê-lo no original] são o tipo mais comum de coleção no SuperCollider. Toda vez que você escreve uma coleção de itens entre colchetes, como \texttt{[0, 1, 2]}, cria uma instância da classe \texttt{Array}. Frequentemente, você se verá manipulando arrays de diversas formas. Aqui está uma pequena seleção de métodos interessantes que arrays entendem:

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Criar uma array
a = [10, 11, 12, 13, 14, 15, 16, 17];

a.reverse;  // inverter
a.scramble; // embaralhar
a.choose;  // escolher um elemento ao acaso
a.size;	  // retorna o tamanho da array
a.at(0);   // recupera um item na posição especificada
a[0]	;  // o mesmo que acima
a.wrapAt(9); // recupera item na posição especificada, relendo do início se > a.size
["wow", 99] ++ a; // concatena duas arrays em uma nova
a ++ \oi;  // um Símbolo (“Symbol”) é entendido como um único caracter
a ++ ‘oi’; // o mesmo que acima
a ++ “oi”; // uma cadeia (“String”) é entendida como uma coleção de caracteres
a.add(44);    // cria uma array adicionando o novo elemento ao final
a.insert(5, “uau”); // insere “uau” na posição 5, empurra itens seguintes para a frente (retorna uma nova array)
a; // rode isso e veja que nenhuma das operações acima mudou a array original
a.put(2, "oops"); // colocar "oops" no índice 2 (destrutivo; volte a rodar a linha acima para verificar)
a.permute(3); // permutar: item na posição 3 vai para a posição zero, e vice-versa
a.mirror;  // faz um palíndromo
a.powerset; // retorna todas as possíveis combinações dos elementos da array
\end{lstlisting}
 

Você pode fazer contas com arrays:

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
[1, 2, 3, 4, 5] + 10;
[1, 2, 3, 4, 5] * 10;
([1, 2, 3, 4, 5] / 7).round(0.01); // note o uso de parênteses para precedência
x = 11; y = 12; // experimente algumas variáveis
[x, y, 9] * 100;
// mas garanta que você só está fazendo contas com números de verdade
[1, 2, 3, 4, "oops", 11] + 10; // resultado estranho
\end{lstlisting}
 

\subsection{Creating new Arrays}

Aqui há algumas maneiras de usar a classe \texttt{Array} para criar novas coleções:

\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Progressão aritmética (definindo tamanho, início e razão da progressão)
Array.series(size: 6, start: 10, step: 3);
// Progressão geométrica (definindo tamanho, início e razão da progressão)
Array.geom(size: 10, start: 1, grow: 2);
// Compare as duas:
Array.series(7, 100, -10); // 7 itens; começando em 100, razão de -10
Array.geom(7, 100, 0.9); // 7 itens; começando em 100; multiplicar por 0.9 a cada vez
// Conheça o método .fill
Array.fill(10, “igual”);
// Compare:
Array.fill(10, rrand(1, 10)); 
Array.fill(10, {rrand(1, 10)}); // a função é reexecutada 10 vezes
// A função definida para o método .fill pode receber um argumento padrão que é um contador.
// O nome do argumento pode ser o que você quiser.
Array.fill(10, {arg counter; counter * 10});
// Por exemplo, gerando uma lista de frequências harmônicas:
Array.fill(10, {arg uau; uau+1 * 440}); 
// O método .newClear
a = Array.newClear(7); // cria uma array vazia do tamanho pedido
a[3] = “uau”; // mesmo que a.put(3, “uau”)
\end{lstlisting}


\subsection{Aquele ponto de exclamação esquisito}

É só uma questão de tempo até que você veja algo como \texttt{30!4} no código de alguém. Essa notação abreviada simplesmente cria um array contendo o mesmo item um determinado número de vezes:

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// Notação abreviada:
30!4;
“alô” ! 10;
// Dá o mesmo resultado que o seguinte:
30.dup(4);
“alô”.dup(10);
// ou
Array.fill(4, 30);
Array.fill(10, “alô”);
\end{lstlisting}
 

\subsection{Os dois pontos entre parênteses}

Aqui está mais uma sintaxe abreviada muito usada para criar arrays.

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// O que é isso?
(50..79);
// É um atalho para gerar um array com uma progressão aritmética de número.
// O atalho acima tem o mesmo resultado que:
series(50, 51, 79);
// ou
Array.series(30, 50, 1);
// Para uma razão diferente de 1, você pode fazer o seguinte:
(50, 53 .. 79); // razão de 3
// Mesmo resultado que:
series(50, 53, 79);
Array.series(10, 50, 3);
\end{lstlisting}

Note que cada comando implica um jeito de pensar ligeiramente diferente. O \texttt{(50..79)} permite que você pense assim: “\emph{apenas me dê um array de 50 a 79}.” Você não precisa necessariamente pensar a quantidade de itens que o array terá. Por outro lado, \texttt{Array.series} permite pensar: “\emph{apenas me dê um array com 30 itens no total, começando a partir do 50}.” Você não precisa necessariamente pensar em qual será o último número da série.

Também note que o atalho usa parênteses, não colchetes. O array resultante, obviamente, virá entre colchetes.
\subsection{Como “fazer” um Array}

Muitas vezes você terá de fazer alguma ação com cada um dos itens de uma coleção. Você pode usar o método \texttt{do} (“faça”) para isso:


\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
~minhasFreqs = Array.fill(10, {rrand(440, 880)});

//Agora vamos fazer uma ação simples com cada um dos itens da lista:
~minhasFreqs.do({arg item, contador; ("Item " ++ contador ++ " é " ++ item ++ " Hz. A nota MIDI mais próxima é " ++ item.cpsmidi.round).postln});

// Se você não precisa do contador, use apenas um argumento:
~minhasFreqs.do({arg item; item.squared.postln});

//Claro que algo simples como o exemplo anterior poderia ser feito assim:
~minhasFreqs.squared;
\end{lstlisting}
 

Em resumo: quando você “faz” um array, você fornece uma função. A mensagem \texttt{do} será iterada cada item do array e aquela função será executada todas as vezes. A função pode receber dois argumentos por definição: o item do array na iteração atual e um contador que acompanha o número de iterações. Os nomes destes argumentos podem ser o que você quiser, mas estarão sempre nesta ordem:: item, contador.

Veja também o método \texttt{collect}, que é muito similar ao \texttt{do}, mas retorna uma nova coleção com todos os resultados intermediários.
