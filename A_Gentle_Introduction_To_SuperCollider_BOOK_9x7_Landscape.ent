\@doanenote {1}
macro:->First
question:
when
you
use
the
number
1
instead
of
\texttt
{inf}
as
the
\texttt
{repeats}
argument
of
the
second
\texttt
{Pseq},
the
Pbind
will
stop
after
6
notes
have
been
played
(that
is,
after
one
full
sequence
of
duration
values
has
been
performed).
Second
question:
to
make
a
Pbind
play
forever,
simply
use
\texttt
{inf}
as
the
\texttt
{repeats}
value
of
all
inner
patterns.
\@endanenote 
\@doanenote {2}
macro:->\\
a)
\texttt
{Pwhite(0,
10)}
will
generate
any
number
between
0
and
10.
\texttt
{Prand([0,
4,
1,
5,
9,
10,
2,
3],
inf)}
will
only
pick
from
the
list,
which
has
\emph
{some}
numbers
between
0
and
10,
but
not
all
(6,
7,
8
are
not
there,
so
they
will
never
occur
in
this
\texttt
{Prand}).
\\
b)
Technically
you
could
use
a
\texttt
{Prand}
if
you
provide
a
list
with
all
numbers
between
0
and
100,
but
it
makes
more
sense
to
use
a
\texttt
{Pwhite}
for
this
task:
\texttt
{Pwhite(0,
100)}.
\\
c)
\texttt
{Prand([0,
1,
2,
3],
inf)}
picks
items
from
the
list
at
random.
\texttt
{Pwhite(0,
3)}
arrives
at
the
same
kind
of
output
through
different
means:
it
will
generate
random
integer
numbers
between
0
and
3,
which
ends
up
being
the
same
pool
of
options
than
the
\texttt
{Prand}
above.
However,
if
you
write
\texttt
{Pwhite(0,
3.0)},
the
output
is
now
different:
because
one
of
the
input
arguments
of
\texttt
{Pwhite}
is
written
as
a
float
(3.0),
it
will
now
output
any
floating
point
number
between
1
and
3,
like
0.154,
1.0,
1.45,
2.999.
\\
d)
The
first
\texttt
{Pbind}
plays
32
notes
(4
times
the
sequence
of
8
notes).
The
second
\texttt
{Pbind}
plays
only
4
notes:
four
random
choices
picked
from
the
list
(remember
that
\texttt
{Prand},
unlike
\texttt
{Pseq},
has
no
obligation
to
play
all
the
notes
from
the
list:
it
will
simply
pick
as
many
random
notes
as
you
tell
it
to).
The
third
and
last
\texttt
{Pbind}
plays
32
notes,
like
the
first.

\@endanenote 
\@doanenote {3}
macro:->First
line:
the
Array
\texttt
{[1,
2,
3,
"wow"]}
is
the
receiving
object;
\texttt
{reverse}
is
the
message.
Second
line:
the
String
"hello"
is
the
receiving
object;
\texttt
{dup}
is
the
message;
\texttt
{4}
is
the
argument
to
\texttt
{dup}.
Third
line:
3.1415
is
the
receiving
object;
\texttt
{round}
is
the
message;
\texttt
{0.1}
is
the
argument
to
\texttt
{round}.
Fourth
line:
\texttt
{100}
is
the
receiver
object,
\texttt
{rand}
is
the
message.
Last
line:
\texttt
{100.0}
is
the
receiver
of
the
message
\texttt
{rand},
the
result
of
which
is
a
random
number
between
0
and
100.
That
number
becomes
the
receiver
of
the
message
\texttt
{round}
with
argument
\texttt
{0.01},
so
that
the
random
number
is
rounded
to
two
decimal
cases.
Then
this
result
becomes
the
receiving
object
of
the
message
\texttt
{dup}
with
argument
\texttt
{4},
which
creates
a
list
with
four
duplicates
of
that
number.
\@endanenote 
\@doanenote {4}
macro:->Rewriting
using
functional
notation
only:
\texttt
{dup(round(rand(100.0),
0.01),
4);}
\@endanenote 
\@doanenote {5}
macro:->
Answers:
\begin
{enumerate}[a)]
\item
24
\item
$\left
[5,
5.123\right
]$
[both
numbers
and
brackets)
\item
Entire
\texttt
{LFSaw}
line
\item
Only
one
\item
0.4
\item
1
and
0.3
\end
{enumerate}

\@endanenote 
\@doanenote {6}
macro:->\texttt
{SinOsc}
is
bipolar
because
it
outputs
numbers
between
-1
and
+1.
\texttt
{LFPulse}
is
unipolar
because
its
output
range
is
0-1
(in
fact,
\texttt
{LFPulse}
in
particular
only
outputs
zeros
or
ones,
nothing
in
between)
\@endanenote 
\@doanenote {7}
macro:->Solution:
\texttt
{a
=
\{Out.ar(0,
SinOsc.ar(freq:
[800,
880],
mul:
LFPulse.ar([2,
3])))\}.play;}
\@endanenote 
\@doanenote {8}
macro:->(a)
The
variable
\texttt
{lfn}
simply
holds
a
\texttt
{LFNoise2}.
The
role
of
\texttt
{LFNoise2}
in
life
is
to
generate
a
new
random
number
every
second
(between
-1
and
+1),
and
slide
to
it
from
the
previous
random
number
(differently
from
\texttt
{LFNoise0},
that
jumps
to
the
new
number
immediately).
The
first
use
of
this
variable
\texttt
{lfn}
is
in
the
\texttt
{freq}
argument
of
the
BPF:
\texttt
{lfn.range(500,
2500)}.
This
takes
the
numbers
between
-1
and
+1
and
scales
them
to
the
range
500-2500.
These
numbers
are
then
used
as
the
center
frequency
of
the
filter.
These
frequencies
are
the
pitches
that
we
hear
sliding
up
and
down.
Finally,
\texttt
{lfn}
is
used
again
to
control
the
position
of
the
panner
\texttt
{Pan2}.
It
is
used
directly
(without
a
\texttt
{.range}
message)
because
the
numbers
are
already
in
the
range
we
want
(-1
to
+1).
The
nice
result
of
this
is
that
we
couple
the
change
of
frequency
with
the
change
of
position.
How?
Every
second,
\texttt
{LFNoise2}
starts
to
slide
toward
a
new
random
number,
and
this
becomes
a
synchronized
change
in
frequency
of
the
filter
and
panning
position.
If
we
had
two
different
\texttt
{LFNoise2}
in
each
place,
the
changes
would
be
uncorrelated
(which
might
be
fine
too,
but
it's
a
different
aural
result).
\\
(b)
a
\texttt
{mul:}
of
1
would
just
be
too
soft.
Because
the
filter
is
so
sharp,
it
takes
so
much
out
of
the
original
signal
that
the
amplitude
drops
too
much.
We
need
to
boost
the
signal
back
to
a
reasonably
audible
range,
so
that's
why
we
have
\texttt
{mul:
20}
at
the
end
of
the
\texttt
{BPF}
line.
\\
(c)
The
rhythm
is
driven
by
the
\texttt
{LFPulse}
that
is
the
\texttt
{mul:}
argument
of
the
\texttt
{Saw}.
\texttt
{LFPulse}
frequency
(how
many
pulses
per
second)
is
controlled
by
an
\texttt
{LFNoise1}
that
produces
numbers
between
1
and
10
(interpolating
between
them).
Those
numbers
are
the
``how
many
notes
per
second''
of
this
patch.

\@endanenote 
