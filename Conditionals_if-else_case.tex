\section{Condicionais: if/else e case}

Se estiver chovendo, saio com um guarda-chuva. Se estiver sol, saio com meus óculos escuros. Nosso dia-a-dia está repleto desse tipo de tomada de decisão. Em programação, estes são os momentos em que o seu código tem de testar alguma condição e realizar ações diferentes dependendo do resultado do teste (verdadeiro ou falso). Há muitos tipos de estruturas condicionais. Vamos dar uma olhada em dois casos simples: \emph{if/else} ("se/senão") e \emph{case} ("no caso de").

A sintaxe de um if/else no SC é: \texttt{if(condition, \{true action\}, \{false action\})}. A condição é um teste booleano, ou seja, precisa retornar um \texttt{true} ("verdadeiro") ou \texttt{false} ("falso"). Se o teste retorna verdadeiro, a primeira função é executada. Se não for verdadeiro, roda-se a segunda. Experimente:

\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// if / else 
if(100 > 50, { "muito verdadeiro".postln }, { "muito falso".postln });
\end{lstlisting}

A tabela abaixo, emprestada do The SuperCollider Book\footnote{Cottle, D. "Beginner's Tutorial." The SuperCollider Book, MIT Press, 2011, p. 33}, apresenta alguns operadores booleanos comuns que podem ser usados.
Note a distinção entre um sinal de igual simples (\texttt{x = 10}) e o sinal de igual duplo (\texttt{x == 10}). O simples significa "\textit{atribua 10 à variável x}," ao passo que o duplo significa "\textit{é x igual a 10?}" Digite e rode alguns exemplos da coluna de verdadeiro ou falso e você verá parecerem os resultados \texttt{true} ou  \texttt{false} aparecerem na Post window.
 
\begin{center}
\begin{tabular}{llll}
\hline 
\textbf{Símbolo} & \textbf{Significado} & \textbf{Exemplo verdadeiro} & \textbf{Exemplo falso} \\ 
\hline 
\texttt{==} & igual a? & \texttt{10 == 10} & \texttt{10 == 99} \\ 
\hline 
\texttt{!=} & diferente de? & \texttt{10 != 99} & \texttt{10 != 10} \\ 
\hline 
\texttt{>} & maior que? & \texttt{10 > 5} & \texttt{10 > 99} \\ 
\hline 
\texttt{<} & menor que? & \texttt{10 < 99} & \texttt{10 < 5} \\ 
\hline 
\texttt{>=} & maior ou igual a?  & \texttt{10 >= 10}, \texttt{10 >= 3} & \texttt{10 >= 99} \\ 
\hline 
\texttt{<=} & menor ou igual a? & \texttt{10 <= 99}, \texttt{10 <= 10} & \texttt{10 <= 9} \\ 
\hline 
\texttt{odd} & é ímpar? & \texttt{15.odd} & \texttt{16.odd} \\ 
\hline 
\texttt{even} & é par? & \texttt{22.even} & \texttt{21.even} \\ 
\hline 
\texttt{isInteger} & é um número inteiro? & \texttt{3.isInteger} & \texttt{3.1415.isInteger} \\ 
\hline 
\texttt{isFloat} & é um número decimal? & \texttt{3.1415.isFloat} & \texttt{3.isFloat} \\ 
\hline 
\texttt{and} & ambas as condições & \texttt{11.odd.and(12.even)} & \texttt{11.odd.and(13.even)} \\ 
\hline 
\texttt{or} & uma das condições & \texttt{or(1.odd, 1.even)} & \texttt{or(2.odd, 1.even)} \\ 
\hline 
\end{tabular} 
\end{center}
 

As últimas duas linhas (\texttt{and}, \texttt{or}) mostram como escrever as expressões mais longas tanto em notação de objeto recebedor quanto em notação funcional.

Outra estrutura útil é \texttt{case}. Ela funciona definindo pares de funções a serem executadas em ordem até que um dos testes retorne verdadeiro:

\texttt{case}

\texttt{\{teste1\} \{ação1\}}

\texttt{\{teste2\} \{ação2\}}

\texttt{\{teste3\} \{ação3\}}

\dots

\texttt{\{testeN\} \{açãoN\}};

A expressão dentro de cada teste tem de retornar ou \texttt{true} ou \texttt{false}. Se o teste1 retorna falso, o programa ignora a ação1 e segue para o teste2. Se teste2 for um falso de novo, ação2 também é ignorada e seguimos para o teste3. Se este for verdadeiro, então a ação3 é executada e o \texttt{case} se encerra ali (mais nenhum teste ou ação é executado). Note que não há vírgulas entre as funções. Simplesmente use um ponto-e-vírgula no fim para marcar o final do enunciado \texttt{case}.

 
\begin{lstlisting}[style=SuperCollider-IDE, basicstyle=\scttfamily\footnotesize]
// case
(
~num = -2;

case
{~num == 0} {"UAU".postln}
{~num == 1} {"UM!".postln}
{~num < 0} {"número negativo!".postln}
{true} {"em último caso".postln};
)
\end{lstlisting}
 
Tente modificar o código acima para obter todos os resultados possíveis. Perceba o truque útil (e opcional) na última linha de \texttt{case} no exemplo acima: como \texttt{true} sempre retorna verdadeiro, pode-se definir uma ação para acontecer "em último caso" que vai sempre ocorrer, mesmo no caso de todas as condições anteriores serem falsas.

Para saber mais, verifique o arquivo de ajuda de Control Structures ("Estruturas de Controle").
